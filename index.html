<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Z-Hospital : 3D Survival</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 8px; height: 8px;
            background: rgba(255, 0, 0, 0.7);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; z-index: 10;
        }

        #instructions {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); color: #ff3333;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer; z-index: 20; text-align: center;
        }

        #ui {
            position: absolute; bottom: 20px; left: 20px;
            color: white; font-size: 20px; text-shadow: 1px 1px #000;
            background: rgba(0,0,0,0.5); padding: 10px;
        }
    </style>
</head>
<body>

    <div id="crosshair"></div>

    <div id="instructions">
        <h1 style="font-size: 40px;">L'HÔPITAL ABANDONNÉ</h1>
        <p>CLIQUEZ POUR ENTRER</p>
        <p style="color: #aaa; font-size: 0.8em;">(ZQSD = Bouger | SOURIS = Viser | CLIC GAUCHE = Tirer)</p>
    </div>

    <div id="ui">ZOMBIES ÉLIMINÉS : <span id="score">0</span></div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { PointerLockControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/PointerLockControls.js';

        // --- 1. CONFIGURATION DE LA SCÈNE ---
        const scene = new THREE.Scene();
        // Brouillard verdâtre pour l'ambiance hôpital toxique
        scene.fog = new THREE.FogExp2(0x112211, 0.03);
        scene.background = new THREE.Color(0x112211);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 1.7; // Hauteur des yeux

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Active les ombres pour plus de réalisme
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- 2. ÉCLAIRAGE (Ambiance sombre et clignotante) ---
        const ambientLight = new THREE.AmbientLight(0x404040, 0.3); // Lumière de base faible
        scene.add(ambientLight);

        // Lumière principale qui viendra du joueur (comme une lampe torche)
        const flashLight = new THREE.SpotLight(0xffffff, 1, 40, Math.PI/5, 0.3, 1);
        flashLight.position.set(0, 2, 0);
        flashLight.castShadow = true;
        scene.add(flashLight);
        scene.add(flashLight.target);

        // --- 3. CONSTRUCTION DE LA MAP (Hôpital) ---
        
        // Le Sol (Carrelage)
        const floorSize = 200;
        const floorGeo = new THREE.PlaneGeometry(floorSize, floorSize);
        // On crée un quadrillage avec des couleurs pour simuler le carrelage sans image externe
        const floorMat = new THREE.MeshPhongMaterial({ color: 0x333333, shininess: 10 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // Grille au sol pour effet carrelage
        const gridHelper = new THREE.GridHelper(floorSize, 50, 0x000000, 0x222222);
        scene.add(gridHelper);

        // Les Murs / Piliers
        const wallMat = new THREE.MeshPhongMaterial({ color: 0x555555 }); // Gris béton
        const wallGeo = new THREE.BoxGeometry(4, 10, 4); // Gros piliers carrés

        for(let i = 0; i < 40; i++) {
            const wall = new THREE.Mesh(wallGeo, wallMat);
            // Position aléatoire, mais pas trop près du centre (départ du joueur)
            let x = (Math.random() - 0.5) * 150;
            let z = (Math.random() - 0.5) * 150;
            if (Math.abs(x) < 10 && Math.abs(z) < 10) x += 20; // Évite le centre

            wall.position.set(x, 5, z); // 5 de hauteur car le mur fait 10 de haut
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
        }

        // --- 4. CRÉATION DES ZOMBIES 3D ---
        const zombies = [];
        const zombieMaterial = new THREE.MeshLambertMaterial({ color: 0x335533 }); // Vert pourri

        function createZombieModel() {
            const zombieGroup = new THREE.Group();

            // Torse
            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.0, 0.3), zombieMaterial);
            torso.position.y = 1.0;
            torso.castShadow = true;
            zombieGroup.add(torso);

            // Tête
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), zombieMaterial);
            head.position.y = 1.7;
            head.castShadow = true;
            zombieGroup.add(head);

            // Bras (tendus vers l'avant)
            const armGeo = new THREE.BoxGeometry(0.2, 0.2, 0.8);
            const leftArm = new THREE.Mesh(armGeo, zombieMaterial);
            leftArm.position.set(-0.4, 1.3, 0.4);
            leftArm.castShadow = true;
            zombieGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeo, zombieMaterial);
            rightArm.position.set(0.4, 1.3, 0.4);
            rightArm.castShadow = true;
            zombieGroup.add(rightArm);

            return zombieGroup;
        }

        function spawnZombie() {
            if (zombies.length > 15) return; // Limite le nombre de zombies
            
            const zombie = createZombieModel();
            const angle = Math.random() * Math.PI * 2;
            const dist = 50 + Math.random() * 30; // Apparaît loin
            zombie.position.set(Math.cos(angle)*dist, 0, Math.sin(angle)*dist);
            
            scene.add(zombie);
            zombies.push({ mesh: zombie, speed: 0.02 + Math.random() * 0.02 });
        }

        setInterval(spawnZombie, 2000);

        // --- 5. CONTRÔLES ET TIR ---
        const controls = new PointerLockControls(camera, document.body);
        const inst = document.getElementById('instructions');
        inst.addEventListener('click', () => controls.lock());
        controls.addEventListener('lock', () => inst.style.display = 'none');
        controls.addEventListener('unlock', () => inst.style.display = 'flex');

        let moveF = false, moveB = false, moveL = false, moveR = false;
        document.addEventListener('keydown', (e) => {
            if(e.code === 'KeyW' || e.code === 'KeyZ') moveF = true;
            if(e.code === 'KeyS') moveB = true;
            if(e.code === 'KeyA' || e.code === 'KeyQ') moveL = true;
            if(e.code === 'KeyD') moveR = true;
        });
        document.addEventListener('keyup', (e) => {
            if(e.code === 'KeyW' || e.code === 'KeyZ') moveF = false;
            if(e.code === 'KeyS') moveB = false;
            if(e.code === 'KeyA' || e.code === 'KeyQ') moveL = false;
            if(e.code === 'KeyD') moveR = false;
        });

        let score = 0;
        const raycaster = new THREE.Raycaster();
        window.addEventListener('mousedown', () => {
            if(!controls.isLocked) return;
            
            // Le tir part du centre de l'écran
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            
            // On vérifie les collisions avec les "enfants" des groupes de zombies (torse, tête...)
            let zombieMeshes = [];
            zombies.forEach(z => zombieMeshes.push(...z.mesh.children));
            
            const intersects = raycaster.intersectObjects(zombieMeshes);

            if(intersects.length > 0) {
                // On a touché une partie d'un zombie, on trouve son groupe parent
                const hitPart = intersects[0].object;
                const zombieGroup = hitPart.parent;
                
                scene.remove(zombieGroup);
                // On retire le zombie du tableau de jeu
                const index = zombies.findIndex(z => z.mesh === zombieGroup);
                if (index > -1) zombies.splice(index, 1);

                score++;
                document.getElementById('score').innerText = score;
            }
        });

        // --- 6. BOUCLE PRINCIPALE ---
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);

            if(controls.isLocked) {
                // 1. Mouvement du joueur
                velocity.z -= velocity.z * 10.0 * 0.016;
                velocity.x -= velocity.x * 10.0 * 0.016;
                direction.z = Number(moveF) - Number(moveB);
                direction.x = Number(moveR) - Number(moveL);
                direction.normalize();
                if (moveF || moveB) velocity.z -= direction.z * 400.0 * 0.016;
                if (moveL || moveR) velocity.x -= direction.x * 400.0 * 0.016;
                controls.moveRight(-velocity.x * 0.016);
                controls.moveForward(-velocity.z * 0.016);

                // La lumière suit le joueur
                flashLight.position.copy(camera.position);
                flashLight.target.position.copy(camera.position).add(camera.getWorldDirection(new THREE.Vector3()));

                // 2. Mouvement des Zombies
                zombies.forEach(zData => {
                    const zMesh = zData.mesh;
                    // Le zombie regarde le joueur
                    zMesh.lookAt(camera.position.x, 0, camera.position.z);
                    // Il avance vers le joueur
                    const dir = new THREE.Vector3().subVectors(camera.position, zMesh.position).setY(0).normalize();
                    zMesh.position.add(dir.multiplyScalar(zData.speed));

                    if(zMesh.position.distanceTo(camera.position) < 1.5) {
                        controls.unlock();
                        alert("VOUS ÊTES MORT DANS L'HÔPITAL. Score: " + score);
                        location.reload();
                    }
                });
            }
            renderer.render(scene, camera);
        }
        animate();

        // Ajustement si on redimensionne la fenêtre
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
