<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Z-TRON : PRECISION</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; color: #0f0; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 14px; height: 14px;
            border: 2px solid #0f0; transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
        }

        /* Menu Overlay */
        #menu-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); color: #0f0;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; text-align: center; border: 4px solid #0f0; box-sizing: border-box;
        }

        .settings-box {
            background: rgba(0, 30, 0, 0.9); border: 1px solid #0f0;
            padding: 20px; margin: 20px; width: 350px;
        }

        .setting-row { margin: 15px 0; text-align: left; }
        label { display: block; font-size: 14px; margin-bottom: 8px; }
        
        /* Personnalisation du slider pour le rendre plus lisible */
        input[type=range] { width: 100%; cursor: pointer; accent-color: #0f0; }

        #start-btn {
            padding: 15px 50px; cursor: pointer; background: #0f0; 
            color: #000; border: none; font-family: inherit; font-size: 24px;
            font-weight: bold; box-shadow: 0 0 20px #0f0;
        }

        #ui { position: absolute; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 10px; border: 1px solid #0f0; z-index: 50; }
    </style>
</head>
<body>

    <div id="crosshair"></div>

    <div id="menu-overlay">
        <h1 id="title">Z-TRON : CALIBRATION</h1>
        
        <div class="settings-box">
            <div class="setting-row">
                <label>SENSIBILITÉ SOURIS : <span id="v-sens">5</span></label>
                <input type="range" id="s-sens" min="0.01" max="0.5" step="0.01" value="0.05">
                <p style="font-size: 10px; color: #888; margin-top:5px;">(Baissez vers la gauche si la caméra tourne trop vite)</p>
            </div>
            <div class="setting-row">
                <label>CHAMP DE VISION : <span id="v-fov">75</span></label>
                <input type="range" id="s-fov" min="60" max="110" step="5" value="75">
            </div>
        </div>

        <button id="start-btn">LANCER LE SYSTÈME</button>
        <p style="margin-top:20px; font-size: 11px;">[ ZQSD ] DÉPLACEMENT | [ CLIC ] TIR | [ ECHAP ] PAUSE</p>
    </div>

    <div id="ui">VAGUE : <span id="wv">1</span> | DATA : <span id="sc">0</span></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 1. SETUP SCÈNE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.7, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 1.0));

        // --- 2. MAP TRON ---
        scene.add(new THREE.GridHelper(400, 100, 0x00ff00, 0x002200));
        
        const wallGeo = new THREE.BoxGeometry(4, 10, 4);
        const wallMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const lineMat = new THREE.LineBasicMaterial({ color: 0x00ff00 });

        for(let i = 0; i < 40; i++) {
            const h = 5 + Math.random() * 12;
            const geo = new THREE.BoxGeometry(4, h, 4);
            const wall = new THREE.Mesh(geo, wallMat);
            let x = (Math.random() - 0.5) * 200;
            let z = (Math.random() - 0.5) * 200;
            if(Math.abs(x) < 12 && Math.abs(z) < 12) x += 30;
            wall.position.set(x, h/2, z);
            wall.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo), lineMat));
            scene.add(wall);
        }

        // --- 3. CONTRÔLES & SENSIBILITÉ ---
        const controls = new PointerLockControls(camera, document.body);
        
        // On applique la sensibilité très basse par défaut
        controls.pointerSpeed = 0.05; 

        const menu = document.getElementById('menu-overlay');
        const startBtn = document.getElementById('start-btn');
        const sSens = document.getElementById('s-sens');
        const sFov = document.getElementById('s-fov');

        // Mise à jour de la sensibilité en direct
        sSens.oninput = (e) => { 
            const val = parseFloat(e.target.value);
            controls.pointerSpeed = val; 
            // On affiche une valeur entière (1 à 50) pour l'utilisateur
            document.getElementById('v-sens').innerText = Math.round(val * 100); 
        };

        sFov.oninput = (e) => { 
            camera.fov = e.target.value; 
            camera.updateProjectionMatrix(); 
            document.getElementById('v-fov').innerText = e.target.value; 
        };

        startBtn.onclick = () => controls.lock();

        controls.addEventListener('lock', () => { menu.style.display = 'none'; });
        controls.addEventListener('unlock', () => { 
            menu.style.display = 'flex'; 
            document.getElementById('title').innerText = "CALIBRATION EN PAUSE";
            startBtn.innerText = "REPRENDRE LE PROTOCOLE";
        });

        // --- 4. GAMEPLAY ---
        let zombies = [];
        let score = 0, wave = 1;

        function spawn() {
            for(let i = 0; i < (3 + wave * 2); i++) {
                const g = new THREE.Group();
                const m = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                g.add(new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 0.4), m));
                const h = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), m);
                h.position.y = 1.4;
                g.add(h);
                const a = Math.random()*Math.PI*2; const d = 40+Math.random()*30;
                g.position.set(Math.cos(a)*d, 0, Math.sin(a)*d);
                scene.add(g);
                zombies.push({ mesh: g, hp: 2 });
            }
        }

        window.addEventListener('mousedown', () => {
            if(!controls.isLocked) return;
            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = ray.intersectObjects(zombies.map(z => z.mesh), true);
            if(hits.length > 0) {
                let obj = hits[0].object;
                while(obj.parent && obj.type !== 'Group') obj = obj.parent;
                const idx = zombies.findIndex(z => z.mesh === obj);
                if(idx !== -1) {
                    zombies[idx].hp--;
                    if(zombies[idx].hp <= 0) {
                        scene.remove(obj);
                        zombies.splice(idx, 1);
                        score += 10; document.getElementById('sc').innerText = score;
                        if(zombies.length === 0) { wave++; document.getElementById('wv').innerText = wave; spawn(); }
                    }
                }
            }
        });

        const keys = {};
        window.onkeydown = (e) => keys[e.code] = true;
        window.onkeyup = (e) => keys[e.code] = false;

        function animate() {
            requestAnimationFrame(animate);
            if(controls.isLocked) {
                const s = 0.16;
                if(keys['KeyW'] || keys['KeyZ']) controls.moveForward(s);
                if(keys['KeyS']) controls.moveForward(-s);
                if(keys['KeyA'] || keys['KeyQ']) controls.moveRight(-s);
                if(keys['KeyD']) controls.moveRight(s);

                zombies.forEach(z => {
                    z.mesh.lookAt(camera.position.x, 0, camera.position.z);
                    const v = new THREE.Vector3().subVectors(camera.position, z.mesh.position).setY(0).normalize();
                    z.mesh.position.add(v.multiplyScalar(0.04 + wave*0.005));
                });
            }
            renderer.render(scene, camera);
        }
        spawn(); animate();
        window.onresize = () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
    </script>
</body>
</html>
