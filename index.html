<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Z-TRON : REBORN</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; color: #0f0; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 14px; height: 14px;
            border: 2px solid #0f0; transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
        }

        #menu-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); color: #0f0;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; text-align: center; border: 4px solid #0f0; box-sizing: border-box;
        }

        .settings-box {
            background: rgba(0, 30, 0, 0.9); border: 1px solid #0f0;
            padding: 20px; margin: 20px; width: 320px;
        }

        .setting-row { margin: 15px 0; text-align: left; }
        label { display: block; font-size: 14px; margin-bottom: 5px; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #0f0; }

        #start-btn {
            padding: 15px 40px; cursor: pointer; background: #0f0; 
            color: #000; border: none; font-family: inherit; font-size: 24px;
            font-weight: bold; box-shadow: 0 0 20px #0f0;
        }

        #ui { position: absolute; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 10px; border: 1px solid #0f0; z-index: 50; }
    </style>
</head>
<body>

    <div id="crosshair"></div>

    <div id="menu-overlay">
        <h1 id="title">Z-TRON SYSTEM</h1>
        
        <div class="settings-box">
            <div class="setting-row">
                <label>SENSIBILITÉ : <span id="v-sens">0.4</span></label>
                <input type="range" id="s-sens" min="0.1" max="1.5" step="0.1" value="0.4">
            </div>
            <div class="setting-row">
                <label>CHAMP DE VISION (FOV) : <span id="v-fov">75</span></label>
                <input type="range" id="s-fov" min="60" max="110" step="5" value="75">
            </div>
        </div>

        <button id="start-btn">INITIALISER LE SYSTÈME</button>
        <p style="margin-top:20px; font-size: 11px;">(ECHAP pour PAUSE / ZQSD pour bouger)</p>
    </div>

    <div id="ui">CYCLES : <span id="wv">1</span> | SCORE : <span id="sc">0</span></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 1. INITIALISATION SCÈNE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.7, 5); // Position de départ

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 1.2));

        // --- 2. CRÉATION DE LA MAP (TRON) ---
        // Grille verte
        const grid = new THREE.GridHelper(400, 80, 0x00ff00, 0x002200);
        scene.add(grid);

        // Murs néon
        const walls = [];
        const wallMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const lineMat = new THREE.LineBasicMaterial({ color: 0x00ff00 });

        for(let i = 0; i < 40; i++) {
            const h = 5 + Math.random() * 10;
            const geo = new THREE.BoxGeometry(4, h, 4);
            const wall = new THREE.Mesh(geo, wallMat);
            
            let x = (Math.random() - 0.5) * 180;
            let z = (Math.random() - 0.5) * 180;
            if(Math.abs(x) < 10 && Math.abs(z) < 10) x += 30; // Zone de spawn vide
            
            wall.position.set(x, h/2, z);
            wall.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo), lineMat));
            scene.add(wall);
            walls.push(wall);
        }

        // --- 3. PARAMÈTRES & CONTRÔLES ---
        const controls = new PointerLockControls(camera, document.body);
        controls.pointerSpeed = 0.4; // Sensibilité douce par défaut

        const menu = document.getElementById('menu-overlay');
        const startBtn = document.getElementById('start-btn');
        const sSens = document.getElementById('s-sens');
        const sFov = document.getElementById('s-fov');

        sSens.oninput = (e) => { 
            controls.pointerSpeed = e.target.value; 
            document.getElementById('v-sens').innerText = e.target.value; 
        };
        sFov.oninput = (e) => { 
            camera.fov = e.target.value; 
            camera.updateProjectionMatrix(); 
            document.getElementById('v-fov').innerText = e.target.value; 
        };

        startBtn.onclick = () => controls.lock();

        controls.addEventListener('lock', () => {
            menu.style.display = 'none';
        });

        controls.addEventListener('unlock', () => {
            menu.style.display = 'flex';
            document.getElementById('title').innerText = "PAUSE";
            startBtn.innerText = "REPRENDRE";
        });

        // --- 4. GAMEPLAY (ZOMBIES) ---
        let zombies = [];
        let score = 0, wave = 1;

        function spawnZombies() {
            for(let i = 0; i < (3 + wave * 2); i++) {
                const group = new THREE.Group();
                const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 0.4), mat);
                body.position.y = 0.6;
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), mat);
                head.position.y = 1.4;
                
                group.add(body, head);
                const angle = Math.random() * Math.PI * 2;
                const dist = 40 + Math.random() * 20;
                group.position.set(Math.cos(angle) * dist, 0, Math.sin(angle) * dist);
                
                scene.add(group);
                zombies.push({ mesh: group, hp: 2 });
            }
        }

        // Tir
        window.addEventListener('mousedown', () => {
            if(!controls.isLocked) return;
            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
            
            const hitList = zombies.map(z => z.mesh);
            const intersects = ray.intersectObjects(hitList, true);
            
            if(intersects.length > 0) {
                let obj = intersects[0].object;
                while(obj.parent && obj.type !== 'Group') obj = obj.parent;
                
                const zIdx = zombies.findIndex(z => z.mesh === obj);
                if(zIdx !== -1) {
                    zombies[zIdx].hp--;
                    if(zombies[zIdx].hp <= 0) {
                        scene.remove(obj);
                        zombies.splice(zIdx, 1);
                        score += 10;
                        document.getElementById('sc').innerText = score;
                        if(zombies.length === 0) {
                            wave++;
                            document.getElementById('wv').innerText = wave;
                            spawnZombies();
                        }
                    }
                }
            }
        });

        // --- 5. ANIMATION ---
        const keys = {};
        window.onkeydown = (e) => keys[e.code] = true;
        window.onkeyup = (e) => keys[e.code] = false;

        function animate() {
            requestAnimationFrame(animate);

            if(controls.isLocked) {
                const moveSpeed = 0.15;
                if(keys['KeyW'] || keys['KeyZ']) controls.moveForward(moveSpeed);
                if(keys['KeyS']) controls.moveForward(-moveSpeed);
                if(keys['KeyA'] || keys['KeyQ']) controls.moveRight(-moveSpeed);
                if(keys['KeyD']) controls.moveRight(moveSpeed);

                zombies.forEach(z => {
                    z.mesh.lookAt(camera.position.x, 0, camera.position.z);
                    const dir = new THREE.Vector3().subVectors(camera.position, z.mesh.position).setY(0).normalize();
                    z.mesh.position.add(dir.multiplyScalar(0.04 + wave * 0.005));
                    
                    if(z.mesh.position.distanceTo(camera.position) < 1.4) {
                        alert("SYSTÈME CORROMPU. SCORE : " + score);
                        location.reload();
                    }
                });
            }
            renderer.render(scene, camera);
        }

        spawnZombies();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
