<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Z-Hospital : Elite Survivor</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 12px; height: 12px;
            border: 2px solid rgba(255, 0, 0, 0.9); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
        }
        #instructions {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); color: #ff3333;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer; z-index: 100; text-align: center;
        }
        #ui {
            position: absolute; bottom: 20px; left: 20px;
            color: white; font-size: 18px; text-shadow: 1px 1px #000;
            background: rgba(0,0,0,0.8); padding: 15px; border-left: 5px solid #ff0000;
            z-index: 50; line-height: 1.5;
        }
        #wave-announcement {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            color: #ff0000; font-size: 50px; font-weight: bold;
            display: none; pointer-events: none; text-shadow: 0 0 15px #000; z-index: 50;
        }
        #minimap-container {
            position: absolute; top: 20px; left: 20px;
            border: 3px solid #444; background: rgba(0, 15, 0, 0.8);
            border-radius: 50%; overflow: hidden; z-index: 50;
        }
    </style>
</head>
<body>

    <div id="crosshair"></div>
    <div id="wave-announcement">VAGUE 1</div>
    <div id="minimap-container"><canvas id="minimap" width="160" height="160"></canvas></div>

    <div id="instructions">
        <h1 style="font-size: 45px; letter-spacing: 5px;">Z-HOSPITAL : ELITE</h1>
        <p style="font-size: 20px;">CLIQUEZ POUR DÉBUTER L'INTERVENTION</p>
        <p style="color: #888;">Certains zombies sont plus gros et résistants que d'autres...</p>
    </div>

    <div id="ui">
        VAGUE : <span id="wave-num">1</span><br>
        MENACES RESTANTES : <span id="zombie-count">0</span><br>
        SCORE : <span id="score">0</span>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { PointerLockControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/PointerLockControls.js';

        // --- INITIALISATION ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050805, 0.035);
        scene.background = new THREE.Color(0x050805);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 1.7;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- LAMPE TORCHE PUISSANCE MAX ---
        const flashLight = new THREE.SpotLight(0xffffff, 10, 80, Math.PI/4.5, 0.3, 1);
        flashLight.castShadow = true;
        flashLight.shadow.mapSize.width = 1024;
        flashLight.shadow.mapSize.height = 1024;
        scene.add(flashLight);
        scene.add(flashLight.target);
        scene.add(new THREE.AmbientLight(0x404040, 0.15));

        // --- DÉCOR ---
        const mapSize = 250;
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(mapSize, mapSize), new THREE.MeshPhongMaterial({ color: 0x1a1a1a }));
        floor.rotation.x = -Math.PI / 2; floor.receiveShadow = true; scene.add(floor);
        scene.add(new THREE.GridHelper(mapSize, 50, 0x000000, 0x003300));

        const wallMat = new THREE.MeshPhongMaterial({ color: 0x2d332d });
        for(let i = 0; i < 60; i++) {
            const h = 5 + Math.random() * 10;
            const wall = new THREE.Mesh(new THREE.BoxGeometry(4, h, 4), wallMat);
            let x = (Math.random() - 0.5) * (mapSize*0.8);
            let z = (Math.random() - 0.5) * (mapSize*0.8);
            if (Math.abs(x) < 20 && Math.abs(z) < 20) x += 40;
            wall.position.set(x, h/2, z); wall.castShadow = true; wall.receiveShadow = true; scene.add(wall);
        }

        // --- MINI-MAP ---
        const mCanvas = document.getElementById('minimap'), mCtx = mCanvas.getContext('2d'), mCenter = 80, mScale = 160 / mapSize;
        function drawMap() {
            mCtx.clearRect(0,0,160,160);
            mCtx.fillStyle = 'rgba(0, 30, 0, 0.6)'; mCtx.fillRect(0,0,160,160);
            // Joueur
            mCtx.fillStyle = '#00ff00'; mCtx.beginPath();
            mCtx.arc(camera.position.x*mScale+mCenter, camera.position.z*mScale+mCenter, 4, 0, Math.PI*2); mCtx.fill();
            // Zombies
            mCtx.fillStyle = '#ff0000';
            zombies.forEach(z => {
                mCtx.beginPath();
                mCtx.arc(z.mesh.position.x*mScale+mCenter, z.mesh.position.z*mScale+mCenter, 2 + z.hp, 0, Math.PI*2); mCtx.fill();
            });
        }

        // --- LOGIQUE DES ZOMBIES (CLASSES) ---
        let wave = 0, score = 0, zombies = [], zombiesToSpawn = 0;
        const zombieMat = new THREE.MeshLambertMaterial({ color: 0x224422 });

        function createZModel(typeScale) {
            const g = new THREE.Group();
            const b = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 0.4), zombieMat.clone()); b.position.y = 0.6;
            const h = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), zombieMat.clone()); h.position.y = 1.4;
            const a = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.8), zombieMat.clone()); a.position.set(0.3, 1.2, 0.4);
            const a2 = a.clone(); a2.position.x = -0.3;
            g.add(b, h, a, a2);
            g.scale.set(typeScale, typeScale, typeScale);
            return g;
        }

        function spawnZombie() {
            const rand = Math.random();
            let hp, scale, speed, color;

            if (rand < 0.15 && wave > 2) { // TANK
                hp = 5; scale = 2.2; speed = 0.02; color = 0x112211;
            } else if (rand > 0.8) { // TRAQUEUR
                hp = 1; scale = 0.7; speed = 0.08; color = 0x446644;
            } else { // NORMAL
                hp = 2; scale = 1.2; speed = 0.045; color = 0x224422;
            }

            const zMesh = createZModel(scale);
            zMesh.children.forEach(part => part.material.color.setHex(color));
            
            const ang = Math.random() * Math.PI * 2;
            zMesh.position.set(Math.cos(ang)*70, 0, Math.sin(ang)*70);
            scene.add(zMesh);
            zombies.push({ mesh: zMesh, hp: hp, speed: speed + (wave * 0.002) });
        }

        function startWave() {
            wave++; zombiesToSpawn = wave * 6;
            document.getElementById('wave-num').innerText = wave;
            const msg = document.getElementById('wave-announcement');
            msg.style.display = 'block'; setTimeout(()=>msg.style.display='none', 2500);
            const timer = setInterval(() => {
                if(zombiesToSpawn > 0) { spawnZombie(); zombiesToSpawn--; updateUI(); }
                else clearInterval(timer);
            }, 900);
        }

        function updateUI() {
            document.getElementById('zombie-count').innerText = zombies.length + zombiesToSpawn;
            document.getElementById('score').innerText = score;
        }

        // --- TIR ET DEGATS ---
        window.addEventListener('mousedown', () => {
            if(!controls.isLocked) return;
            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
            let targets = []; zombies.forEach(z => targets.push(...z.mesh.children));
            const hit = ray.intersectObjects(targets);

            if(hit.length > 0) {
                const group = hit[0].object.parent;
                const zData = zombies.find(z => z.mesh === group);
                
                if(zData) {
                    zData.hp--;
                    // Effet visuel de dégât (clignotement)
                    group.children.forEach(p => p.material.emissive.setHex(0x440000));
                    setTimeout(() => group.children.forEach(p => p.material.emissive.setHex(0x000000)), 100);

                    if(zData.hp <= 0) {
                        scene.remove(group);
                        zombies.splice(zombies.indexOf(zData), 1);
                        score += (zData.speed > 0.06) ? 25 : 15;
                        if(zombies.length === 0 && zombiesToSpawn === 0) setTimeout(startWave, 2500);
                    }
                    updateUI();
                }
            }
        });

        // --- SYSTEME DE JEU ---
        const controls = new PointerLockControls(camera, document.body);
        const inst = document.getElementById('instructions');
        inst.addEventListener('click', () => { controls.lock(); inst.style.display = 'none'; });
        controls.addEventListener('unlock', () => inst.style.display = 'flex');

        let keys = {};
        document.addEventListener('keydown', (e) => keys[e.code] = true);
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        function animate() {
            requestAnimationFrame(animate);
            if(controls.isLocked) {
                const s = 0.15;
                if(keys['KeyW'] || keys['KeyZ'] || keys['ArrowUp']) controls.moveForward(s);
                if(keys['KeyS'] || keys['ArrowDown']) controls.moveForward(-s*0.8);
                if(keys['KeyA'] || keys['KeyQ'] || keys['ArrowLeft']) controls.moveRight(-s*0.7);
                if(keys['KeyD'] || keys['ArrowRight']) controls.moveRight(s*0.7);

                flashLight.position.copy(camera.position);
                const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                flashLight.target.position.copy(camera.position).add(dir);

                zombies.forEach(z => {
                    z.mesh.lookAt(camera.position.x, 0, camera.position.z);
                    const d = new THREE.Vector3().subVectors(camera.position, z.mesh.position).setY(0).normalize();
                    z.mesh.position.add(d.multiplyScalar(z.speed));
                    if(z.mesh.position.distanceTo(camera.position) < 1.5 * z.mesh.scale.x) {
                        controls.unlock(); alert("INFECTÉ ! SCORE FINAL: " + score); location.reload();
                    }
                });
                drawMap();
            }
            renderer.render(scene, camera);
        }

        startWave(); animate();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
