<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Z-Hospital : Ultimate Version</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 12px; height: 12px;
            border: 2px solid rgba(255, 0, 0, 0.9); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
        }
        /* Écran d'accueil forcé au premier plan */
        #instructions {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); color: #ff3333;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer; z-index: 9999; text-align: center;
        }
        #ui-left {
            position: absolute; bottom: 20px; left: 20px;
            color: white; font-size: 18px; text-shadow: 1px 1px #000;
            background: rgba(0,0,0,0.8); padding: 15px; border-left: 5px solid #ff0000; z-index: 50;
        }
        #ui-right {
            position: absolute; bottom: 20px; right: 20px;
            background: rgba(0,0,0,0.8); padding: 15px; border-right: 5px solid #00ff00;
            z-index: 50; width: 250px;
        }
        .hp-container { width: 100%; height: 20px; background: #333; margin-top: 5px; }
        #hp-bar { width: 100%; height: 100%; background: #00ff00; transition: width 0.2s; }
        #minimap-container {
            position: absolute; top: 20px; left: 20px;
            border: 2px solid #555; background: rgba(0, 10, 0, 0.8);
            border-radius: 50%; overflow: hidden; z-index: 50;
        }
    </style>
</head>
<body>

    <div id="crosshair"></div>
    <div id="minimap-container"><canvas id="minimap" width="150" height="150"></canvas></div>

    <div id="instructions">
        <h1 style="font-size: 40px;">CLIQUEZ ICI POUR LANCER</h1>
        <p>Si le jeu ne se lance pas, vérifiez votre connexion internet.</p>
        <p style="color: #666;">(Z-Q-S-D pour bouger)</p>
    </div>

    <div id="ui-left">
        VAGUE : <span id="wave-num">1</span> | SCORE : <span id="score">0</span>
    </div>

    <div id="ui-right">
        <span style="color: white;">SANTÉ DU JOUEUR</span>
        <div class="hp-container"><div id="hp-bar"></div></div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 1. SETUP SCÈNE ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020502, 0.04);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- 2. LUMIÈRE (PROJECTEUR ULTRA PUISSANT) ---
        // Intensité mise à 25 pour une visibilité totale dans le faisceau
        const flashLight = new THREE.SpotLight(0xffffff, 25, 120, Math.PI/4, 0.2, 1);
        flashLight.castShadow = true;
        scene.add(flashLight);
        scene.add(flashLight.target);
        scene.add(new THREE.AmbientLight(0x404040, 0.05));

        // --- 3. COLLISIONS ET DÉCOR ---
        const walls = [];
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), new THREE.MeshPhongMaterial({ color: 0x111111 }));
        floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

        for(let i=0; i<60; i++) {
            const wall = new THREE.Mesh(new THREE.BoxGeometry(4, 10, 4), new THREE.MeshPhongMaterial({ color: 0x222222 }));
            let x = (Math.random()-0.5)*200; let z = (Math.random()-0.5)*200;
            if(Math.abs(x) < 20 && Math.abs(z) < 20) x += 40;
            wall.position.set(x, 5, z); wall.castShadow = true; wall.receiveShadow = true;
            scene.add(wall); walls.push(wall);
        }

        // --- 4. GAMEPLAY ---
        let playerHP = 100, score = 0, wave = 0, zombies = [];
        const controls = new PointerLockControls(camera, document.body);
        const inst = document.getElementById('instructions');

        // FIX LANCEMENT : On cache l'écran AVANT de tenter le lock
        inst.addEventListener('mousedown', () => {
            inst.style.display = 'none'; 
            controls.lock();
        });

        function spawnWave() {
            wave++; document.getElementById('wave-num').innerText = wave;
            for(let i=0; i < (wave * 5); i++) {
                const isBig = Math.random() > 0.8;
                const hp = isBig ? 5 : 1;
                const scale = isBig ? 2.5 : 1.1;
                const speed = isBig ? 0.02 : 0.06;

                const g = new THREE.Group();
                const mat = new THREE.MeshLambertMaterial({ color: isBig ? 0x113311 : 0x224422 });
                const b = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 0.4), mat); b.position.y = 0.6;
                const h = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), mat); h.position.y = 1.4;
                g.add(b, h); g.scale.set(scale, scale, scale);

                const ang = Math.random() * Math.PI * 2;
                g.position.set(Math.cos(ang)*80, 0, Math.sin(ang)*80);
                scene.add(g);
                zombies.push({ mesh: g, hp: hp, speed: speed, radius: 0.8 * scale });
            }
        }

        // --- 5. MINI-MAP ---
        const mCan = document.getElementById('minimap'), mCtx = mCan.getContext('2d');
        function drawMap() {
            mCtx.fillStyle = 'rgba(0,10,0,0.5)'; mCtx.fillRect(0,0,150,150);
            // Joueur
            mCtx.fillStyle = '#0f0'; 
            mCtx.fillRect(75 + camera.position.x/2, 75 + camera.position.z/2, 4, 4);
            // Zombies
            mCtx.fillStyle = '#f00';
            zombies.forEach(z => mCtx.fillRect(75 + z.mesh.position.x/2, 75 + z.mesh.position.z/2, 3, 3));
        }

        // --- 6. TIR ET COLLISIONS MURS ---
        window.addEventListener('mousedown', () => {
            if(!controls.isLocked) return;
            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = ray.intersectObjects(scene.children, true);
            for(let res of intersects) {
                let obj = res.object;
                while(obj.parent && obj.type !== 'Group') obj = obj.parent;
                const z = zombies.find(z => z.mesh === obj);
                if(z) {
                    z.hp--;
                    if(z.hp <= 0) {
                        scene.remove(z.mesh);
                        zombies.splice(zombies.indexOf(z), 1);
                        score += 10; document.getElementById('score').innerText = score;
                        if(zombies.length === 0) spawnWave();
                    }
                    break;
                }
            }
        });

        let keys = {};
        window.addEventListener('keydown', (e) => keys[e.code] = true);
        window.addEventListener('keyup', (e) => keys[e.code] = false);

        function animate() {
            requestAnimationFrame(animate);
            if(controls.isLocked) {
                if(keys['KeyW'] || keys['KeyZ']) controls.moveForward(0.15);
                if(keys['KeyS']) controls.moveForward(-0.15);
                if(keys['KeyA'] || keys['KeyQ']) controls.moveRight(-0.15);
                if(keys['KeyD']) controls.moveRight(0.15);

                flashLight.position.copy(camera.position);
                const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                flashLight.target.position.copy(camera.position).add(dir);

                zombies.forEach(z => {
                    z.mesh.lookAt(camera.position.x, 0, camera.position.z);
                    const v = new THREE.Vector3().subVectors(camera.position, z.mesh.position).setY(0).normalize();
                    
                    // COLLISION ZOMBIE / MUR
                    let nextPos = z.mesh.position.clone().add(v.multiplyScalar(z.speed));
                    let hitWall = false;
                    for(let w of walls) {
                        if(Math.abs(nextPos.x - w.position.x) < 2.8 && Math.abs(nextPos.z - w.position.z) < 2.8) {
                            hitWall = true; break;
                        }
                    }
                    if(!hitWall) z.mesh.position.copy(nextPos);

                    // DEGATS JOUEUR
                    if(z.mesh.position.distanceTo(camera.position) < 1.8) {
                        playerHP -= 0.3;
                        document.getElementById('hp-bar').style.width = playerHP + "%";
                        if(playerHP <= 0) location.reload();
                    }
                });
                drawMap();
            }
            renderer.render(scene, camera);
        }
        spawnWave(); animate();
    </script>
</body>
</html>
