<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Z-TRON : ULTRA-LOCK</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; color: #0f0; }
        
        /* VISEUR FIXE AU CENTRE */
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px;
            border: 2px solid #0f0; border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; z-index: 10;
            box-shadow: 0 0 15px #0f0;
        }
        #crosshair::after { content: ''; position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background: #0f0; transform: translate(-50%, -50%); border-radius: 50%; }

        #menu-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); color: #0f0;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; text-align: center;
        }

        .settings-box { background: rgba(0, 30, 0, 0.9); border: 2px solid #0f0; padding: 25px; margin: 20px; width: 300px; }
        input[type=range] { width: 100%; accent-color: #0f0; cursor: pointer; }

        #start-btn {
            padding: 15px 40px; cursor: pointer; background: #0f0; color: #000;
            border: none; font-family: inherit; font-size: 24px; font-weight: bold;
            box-shadow: 0 0 20px #0f0;
        }

        #ui { position: absolute; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 15px; border: 1px solid #0f0; z-index: 50; }
        #combo-ui { color: #fff; font-weight: bold; font-size: 24px; text-shadow: 0 0 10px #0f0; }
    </style>
</head>
<body>

    <div id="crosshair"></div>

    <div id="menu-overlay">
        <h1>Z-TRON : KERNEL LOCK</h1>
        <div class="settings-box">
            <label>SENSIBILITÉ : <span id="v-sens">5</span></label>
            <input type="range" id="s-sens" min="0.0005" max="0.01" step="0.0005" value="0.003">
        </div>
        <button id="start-btn">ACTIVER LA CAPTURE SOURIS</button>
    </div>

    <div id="ui">
        VAGUE : <span id="wv">1</span> | SCORE : <span id="sc">0</span><br>
        <div id="combo-ui">COMBO x1</div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- SCÈNE ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 1.0));
        scene.add(new THREE.GridHelper(400, 100, 0x00ff00, 0x001100));

        // --- ÉTAT DU JEU ---
        let isLocked = false;
        let sensitivity = 0.003;
        let score = 0, wave = 1, combo = 1, lastKillTime = 0;
        let zombies = [], particles = [];

        // --- GESTION DU LOCK (LA SOLUTION) ---
        const startBtn = document.getElementById('start-btn');
        const menu = document.getElementById('menu-overlay');

        startBtn.addEventListener('click', () => {
            renderer.domElement.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === renderer.domElement) {
                isLocked = true;
                menu.style.display = 'none';
            } else {
                isLocked = false;
                menu.style.display = 'flex';
            }
        });

        // Rotation de la caméra liée au mouvement relatif
        document.addEventListener('mousemove', (e) => {
            if (isLocked) {
                // On fait tourner la caméra selon le mouvement de la souris "cachée"
                camera.rotation.y -= e.movementX * sensitivity;
                camera.rotation.x -= e.movementY * sensitivity;
                // On bloque la vue verticale pour éviter de faire un salto arrière
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
            }
        });
        camera.rotation.order = 'YXZ'; // Important pour un contrôle FPS

        document.getElementById('s-sens').oninput = (e) => {
            sensitivity = parseFloat(e.target.value);
            document.getElementById('v-sens').innerText = Math.round(sensitivity * 2000);
        };

        // --- GAMEPLAY ---
        function spawn() {
            for(let i=0; i<(3+wave*2); i++) {
                const g = new THREE.Group();
                const m = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                g.add(new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.4, 0.5), m));
                const h = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), m); h.position.y = 1.6;
                g.add(h);
                const a = Math.random()*Math.PI*2, d = 50+Math.random()*20;
                g.position.set(Math.cos(a)*d, 0, Math.sin(a)*d);
                scene.add(g);
                zombies.push({ mesh: g, hp: 2 });
            }
        }

        window.addEventListener('mousedown', () => {
            if(!isLocked) return;
            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = ray.intersectObjects(zombies.map(z => z.mesh), true);
            
            if(hits.length > 0) {
                let obj = hits[0].object;
                while(obj.parent && obj.type !== 'Group') obj = obj.parent;
                const idx = zombies.findIndex(z => z.mesh === obj);
                if(idx !== -1) {
                    zombies[idx].hp--;
                    if(zombies[idx].hp <= 0) {
                        // Gestion Combo
                        const now = Date.now();
                        if(now - lastKillTime < 2000) combo++;
                        else combo = 1;
                        lastKillTime = now;
                        document.getElementById('combo-ui').innerText = "COMBO x" + combo;

                        score += 10 * combo;
                        document.getElementById('sc').innerText = score;
                        
                        scene.remove(obj);
                        zombies.splice(idx, 1);
                        if(zombies.length === 0) { wave++; document.getElementById('wv').innerText = wave; spawn(); }
                    }
                }
            }
        });

        // --- BOUCLE ---
        const keys = {};
        window.onkeydown = (e) => keys[e.code] = true;
        window.onkeyup = (e) => keys[e.code] = false;

        function animate() {
            requestAnimationFrame(animate);
            if(isLocked) {
                const s = 0.18;
                if(keys['KeyW'] || keys['KeyZ']) camera.translateZ(-s);
                if(keys['KeyS']) camera.translateZ(s);
                if(keys['KeyA'] || keys['KeyQ']) camera.translateX(-s);
                if(keys['KeyD']) camera.translateX(s);
                camera.position.y = 1.7; // Garder la tête à niveau

                zombies.forEach(z => {
                    z.mesh.lookAt(camera.position.x, 0, camera.position.z);
                    const v = new THREE.Vector3().subVectors(camera.position, z.mesh.position).setY(0).normalize();
                    z.mesh.position.add(v.multiplyScalar(0.04 + wave*0.005));
                    if(z.mesh.position.distanceTo(camera.position) < 1.6) location.reload();
                });
            }
            renderer.render(scene, camera);
        }
        spawn(); animate();
    </script>
</body>
</html>
