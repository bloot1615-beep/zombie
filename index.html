<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Z-TRON : LINKED</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; color: #0f0; }
        
        /* VISEUR : Garanti au centre exact */
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 16px; height: 16px;
            border: 2px solid #0f0;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; z-index: 10;
            box-shadow: 0 0 10px #0f0;
        }

        #menu-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); color: #0f0;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; text-align: center; border: 4px solid #0f0; box-sizing: border-box;
        }

        .settings-box { background: rgba(0, 30, 0, 0.9); border: 1px solid #0f0; padding: 20px; margin: 20px; width: 320px; }
        .setting-row { margin: 15px 0; text-align: left; }
        input[type=range] { width: 100%; accent-color: #0f0; cursor: pointer; }

        #start-btn {
            padding: 15px 40px; cursor: pointer; background: #0f0; 
            color: #000; border: none; font-family: inherit; font-size: 24px;
            font-weight: bold; box-shadow: 0 0 20px #0f0;
        }

        #ui { position: absolute; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 10px; border: 1px solid #0f0; z-index: 50; }
    </style>
</head>
<body>

    <div id="crosshair"></div>

    <div id="menu-overlay">
        <h1>Z-TRON : SYNC OK</h1>
        <div class="settings-box">
            <div class="setting-row">
                <label>SENSIBILITÉ : <span id="v-sens">5</span></label>
                <input type="range" id="s-sens" min="0.001" max="0.1" step="0.001" value="0.005">
            </div>
        </div>
        <button id="start-btn">LANCER LA SYNCHRO</button>
    </div>

    <div id="ui">VAGUE : <span id="wv">1</span> | DATA : <span id="sc">0</span></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- SCÈNE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.7, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 1.0));
        scene.add(new THREE.GridHelper(400, 100, 0x00ff00, 0x002200));

        // --- MURS ---
        const wallGeo = new THREE.BoxGeometry(4, 10, 4);
        const wallMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const lineMat = new THREE.LineBasicMaterial({ color: 0x00ff00 });
        for(let i=0; i<40; i++){
            const m = new THREE.Mesh(wallGeo, wallMat);
            const x = (Math.random()-0.5)*200; const z = (Math.random()-0.5)*200;
            if(Math.abs(x)<10 && Math.abs(z)<10) continue;
            m.position.set(x, 5, z);
            m.add(new THREE.LineSegments(new THREE.EdgesGeometry(wallGeo), lineMat));
            scene.add(m);
        }

        // --- CONTRÔLES (CORRIGÉS) ---
        const controls = new PointerLockControls(camera, document.body);
        const menu = document.getElementById('menu-overlay');
        const startBtn = document.getElementById('start-btn');
        const sSens = document.getElementById('s-sens');
        
        // Sensibilité très basse par défaut
        let sensitivity = 0.005; 
        sSens.oninput = (e) => { 
            sensitivity = parseFloat(e.target.value);
            document.getElementById('v-sens').innerText = Math.round(sensitivity * 1000); 
        };

        startBtn.onclick = () => controls.lock();
        controls.addEventListener('lock', () => menu.style.display = 'none');
        controls.addEventListener('unlock', () => menu.style.display = 'flex');

        // Surcharge manuelle de la rotation pour plus de contrôle sur la sensibilité
        document.addEventListener('mousemove', (event) => {
            if (controls.isLocked) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                // Formule de rotation : $\theta = \text{movement} \times \text{sensitivity}$
                camera.rotation.y -= movementX * sensitivity;
                camera.rotation.x -= movementY * sensitivity;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
            }
        });

        // --- GAMEPLAY & PARTICULES ---
        let zombies = [];
        let particles = [];
        let score = 0, wave = 1;

        function createParticles(pos) {
            for(let i=0; i<15; i++) {
                const p = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 0.1, 0.1),
                    new THREE.MeshBasicMaterial({ color: 0x00ff00 })
                );
                p.position.copy(pos);
                const vel = new THREE.Vector3(
                    (Math.random()-0.5)*0.2,
                    Math.random()*0.3,
                    (Math.random()-0.5)*0.2
                );
                scene.add(p);
                particles.push({ mesh: p, vel: vel, life: 1.0 });
            }
        }

        function spawn() {
            for(let i=0; i<(3+wave*2); i++){
                const g = new THREE.Group();
                const m = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                g.add(new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 0.4), m));
                const h = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), m); h.position.y = 1.4;
                g.add(h);
                const a = Math.random()*Math.PI*2; const d = 40+Math.random()*20;
                g.position.set(Math.cos(a)*d, 0, Math.sin(a)*d);
                scene.add(g);
                zombies.push({ mesh: g, hp: 2 });
            }
        }

        window.addEventListener('mousedown', () => {
            if(!controls.isLocked) return;
            const ray = new THREE.Raycaster();
            // Le tir part toujours du centre exact (0,0)
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = ray.intersectObjects(zombies.map(z => z.mesh), true);
            if(hits.length > 0) {
                let obj = hits[0].object;
                while(obj.parent && obj.type !== 'Group') obj = obj.parent;
                const idx = zombies.findIndex(z => z.mesh === obj);
                if(idx !== -1) {
                    zombies[idx].hp--;
                    if(zombies[idx].hp <= 0) {
                        createParticles(obj.position);
                        scene.remove(obj);
                        zombies.splice(idx, 1);
                        score += 10; document.getElementById('sc').innerText = score;
                        if(zombies.length === 0) { wave++; document.getElementById('wv').innerText = wave; spawn(); }
                    }
                }
            }
        });

        // --- BOUCLE ---
        const keys = {};
        window.onkeydown = (e) => keys[e.code] = true;
        window.onkeyup = (e) => keys[e.code] = false;

        function animate() {
            requestAnimationFrame(animate);
            if(controls.isLocked) {
                const s = 0.15;
                if(keys['KeyW'] || keys['KeyZ']) controls.moveForward(s);
                if(keys['KeyS']) controls.moveForward(-s);
                if(keys['KeyA'] || keys['KeyQ']) controls.moveRight(-s);
                if(keys['KeyD']) controls.moveRight(s);

                zombies.forEach(z => {
                    z.mesh.lookAt(camera.position.x, 0, camera.position.z);
                    const v = new THREE.Vector3().subVectors(camera.position, z.mesh.position).setY(0).normalize();
                    z.mesh.position.add(v.multiplyScalar(0.04 + wave*0.005));
                });

                // Animation particules
                for(let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.mesh.position.add(p.vel);
                    p.life -= 0.02;
                    p.mesh.scale.setScalar(p.life);
                    if(p.life <= 0) {
                        scene.remove(p.mesh);
                        particles.splice(i, 1);
                    }
                }
            }
            renderer.render(scene, camera);
        }
        spawn(); animate();
    </script>
</body>
</html>
